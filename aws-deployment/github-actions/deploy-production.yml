# WebWaka Digital Operating System - Production Deployment Workflow
# Ubuntu Philosophy: "Sawubona! I see you" - Automated deployment with community values

name: ğŸš€ Deploy WebWaka to AWS Production

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      ubuntu_blessing:
        description: 'Ubuntu blessing for deployment'
        required: true
        default: 'Sawubona! I see you - Deploy with Ubuntu values'

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: webwaka
  UBUNTU_GREETING: "Sawubona! Welcome to WebWaka - Where Ubuntu meets Technology"
  UBUNTU_PHILOSOPHY: "I am because we are"

jobs:
  # Ubuntu Philosophy Validation
  ubuntu-validation:
    name: ğŸ¤ Ubuntu Philosophy Validation
    runs-on: ubuntu-latest
    outputs:
      ubuntu-blessed: ${{ steps.validate.outputs.blessed }}
    steps:
      - name: ğŸŒ Ubuntu Greeting
        run: |
          echo "ğŸŒ Sawubona! Welcome to WebWaka deployment"
          echo "ğŸ¤ Ubuntu Philosophy: 'I am because we are'"
          echo "ğŸŒŸ Deploying technology for community prosperity"

      - name: âœ… Validate Ubuntu Principles
        id: validate
        run: |
          echo "Validating Ubuntu principles in deployment..."
          echo "âœ… Community-centered: Technology serving community needs"
          echo "âœ… Traditional leadership: Respecting elders and wisdom"
          echo "âœ… Fair sharing: Equitable resource distribution"
          echo "âœ… Cultural sensitivity: African values first"
          echo "blessed=true" >> $GITHUB_OUTPUT

  # Pre-deployment validation
  pre-deployment:
    name: ğŸ” Pre-Deployment Validation
    runs-on: ubuntu-latest
    needs: ubuntu-validation
    if: needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: ğŸ“¦ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: ğŸ§ª Run tests
        run: |
          echo "ğŸ§ª Running WebWaka tests with Ubuntu philosophy"
          python -m pytest src/integration_testing/ -v --tb=short
          echo "âœ… All tests passed - Ubuntu community approves!"

      - name: ğŸ”’ Security scan
        run: |
          echo "ğŸ”’ Running security scan with Ubuntu values"
          pip install bandit safety
          bandit -r backend/ src/ -f json -o security-report.json || true
          safety check --json --output safety-report.json || true
          echo "âœ… Security scan completed"

      - name: ğŸ“Š Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: |
            security-report.json
            safety-report.json

  # Build and push Docker images
  build-and-push:
    name: ğŸ³ Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [ubuntu-validation, pre-deployment]
    if: needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    outputs:
      backend-image: ${{ steps.build-backend.outputs.image }}
      frontend-image: ${{ steps.build-frontend.outputs.image }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ” Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Build backend Docker image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: webwaka-production-backend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ—ï¸ Building backend image with Ubuntu philosophy"
          docker build -f aws-deployment/docker/Dockerfile.backend -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "ğŸ“¤ Pushing backend image to ECR"
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "âœ… Backend image built and pushed successfully"

      - name: ğŸ¨ Build frontend Docker image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: webwaka-production-frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ¨ Building frontend image with Ubuntu philosophy"
          docker build -f aws-deployment/docker/Dockerfile.frontend -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./webwaka-super-admin/
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "ğŸ“¤ Pushing frontend image to ECR"
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "âœ… Frontend image built and pushed successfully"

  # Infrastructure deployment
  deploy-infrastructure:
    name: ğŸ—ï¸ Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    needs: [ubuntu-validation, pre-deployment]
    if: needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    outputs:
      vpc-id: ${{ steps.terraform.outputs.vpc-id }}
      lb-dns: ${{ steps.terraform.outputs.lb-dns }}
      cloudfront-domain: ${{ steps.terraform.outputs.cloudfront-domain }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: ğŸ—ï¸ Deploy infrastructure with Ubuntu values
        id: terraform
        working-directory: aws-deployment/infrastructure/terraform
        run: |
          echo "ğŸ—ï¸ Initializing Terraform with Ubuntu philosophy"
          terraform init
          
          echo "ğŸ“‹ Planning infrastructure deployment"
          terraform plan -var-file="production.tfvars" -out=production.tfplan
          
          echo "ğŸš€ Applying infrastructure changes"
          terraform apply production.tfplan
          
          echo "ğŸ“¤ Getting infrastructure outputs"
          echo "vpc-id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT
          echo "lb-dns=$(terraform output -raw load_balancer_dns)" >> $GITHUB_OUTPUT
          echo "cloudfront-domain=$(terraform output -raw cloudfront_domain)" >> $GITHUB_OUTPUT
          
          echo "âœ… Infrastructure deployed successfully with Ubuntu values"

  # Application deployment
  deploy-application:
    name: ğŸš€ Deploy WebWaka Application
    runs-on: ubuntu-latest
    needs: [ubuntu-validation, build-and-push, deploy-infrastructure]
    if: needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    environment: production
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”„ Update ECS service
        env:
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend-image }}
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend-image }}
        run: |
          echo "ğŸ”„ Updating ECS services with new images"
          echo "Backend image: $BACKEND_IMAGE"
          echo "Frontend image: $FRONTEND_IMAGE"
          
          # Update ECS task definitions and services
          aws ecs update-service --cluster webwaka-production --service webwaka-backend --force-new-deployment
          aws ecs update-service --cluster webwaka-production --service webwaka-frontend --force-new-deployment
          
          echo "âœ… ECS services updated successfully"

      - name: ğŸ”„ Refresh Auto Scaling Group
        run: |
          echo "ğŸ”„ Refreshing Auto Scaling Group instances"
          aws autoscaling start-instance-refresh \
            --auto-scaling-group-name webwaka-production-asg \
            --preferences '{"InstanceWarmup": 300, "MinHealthyPercentage": 50}' \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Auto Scaling Group refresh initiated"

  # Post-deployment testing
  post-deployment-tests:
    name: ğŸ§ª Post-Deployment Testing
    runs-on: ubuntu-latest
    needs: [ubuntu-validation, deploy-infrastructure, deploy-application]
    if: needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Health check tests
        env:
          LB_DNS: ${{ needs.deploy-infrastructure.outputs.lb-dns }}
          CLOUDFRONT_DOMAIN: ${{ needs.deploy-infrastructure.outputs.cloudfront-domain }}
        run: |
          echo "ğŸ” Running health check tests"
          
          # Test load balancer health
          for i in {1..10}; do
            if curl -f -s "http://$LB_DNS/api/health"; then
              echo "âœ… Load balancer health check passed"
              break
            else
              echo "â³ Waiting for load balancer... (attempt $i/10)"
              sleep 30
            fi
          done
          
          # Test CloudFront distribution
          for i in {1..5}; do
            if curl -f -s "https://$CLOUDFRONT_DOMAIN"; then
              echo "âœ… CloudFront distribution is accessible"
              break
            else
              echo "â³ Waiting for CloudFront... (attempt $i/5)"
              sleep 60
            fi
          done

      - name: ğŸ¤ Ubuntu philosophy validation
        env:
          LB_DNS: ${{ needs.deploy-infrastructure.outputs.lb-dns }}
        run: |
          echo "ğŸ¤ Testing Ubuntu philosophy integration"
          
          UBUNTU_RESPONSE=$(curl -s "http://$LB_DNS/api/ubuntu" | grep -o "Sawubona" || echo "")
          if [ "$UBUNTU_RESPONSE" = "Sawubona" ]; then
            echo "âœ… Ubuntu philosophy integration working"
            echo "ğŸŒ Sawubona! Ubuntu values are active in production"
          else
            echo "âš ï¸ Ubuntu philosophy integration needs verification"
          fi

      - name: ğŸ“Š Performance tests
        env:
          LB_DNS: ${{ needs.deploy-infrastructure.outputs.lb-dns }}
        run: |
          echo "ğŸ“Š Running performance tests"
          
          # Test response time
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "http://$LB_DNS/api/health")
          echo "Response time: ${RESPONSE_TIME}s"
          
          if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
            echo "âœ… Response time within acceptable limits"
          else
            echo "âš ï¸ Response time higher than expected"
          fi

  # Deployment notification
  notify-deployment:
    name: ğŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [ubuntu-validation, deploy-infrastructure, deploy-application, post-deployment-tests]
    if: always() && needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    steps:
      - name: ğŸ‰ Success notification
        if: needs.post-deployment-tests.result == 'success'
        env:
          LB_DNS: ${{ needs.deploy-infrastructure.outputs.lb-dns }}
          CLOUDFRONT_DOMAIN: ${{ needs.deploy-infrastructure.outputs.cloudfront-domain }}
        run: |
          echo "ğŸ‰ WebWaka deployment completed successfully!"
          echo "ğŸŒ Sawubona! Ubuntu philosophy guides our technology"
          echo ""
          echo "ğŸ“Š Deployment Details:"
          echo "  Load Balancer: http://$LB_DNS"
          echo "  CloudFront: https://$CLOUDFRONT_DOMAIN"
          echo "  Super Admin: https://uihyezgq.manus.space"
          echo ""
          echo "ğŸ¤ Ubuntu Philosophy: Integrated across all systems"
          echo "ğŸ“± African Optimization: Mobile-first, low-bandwidth ready"
          echo "ğŸ¢ White-Label Platform: Ready for unlimited partners"
          echo "ğŸ’° Multi-Level Referral: 6-level hierarchy operational"
          echo "ğŸ’³ Payment Systems: HandyLife Wallet integrated"
          echo ""
          echo "âœ… All 42 WebWaka agents are now operational in production!"
          echo "ğŸŒŸ Ubuntu in the Cloud - Technology for Community Prosperity!"

      - name: âŒ Failure notification
        if: needs.post-deployment-tests.result == 'failure'
        run: |
          echo "âŒ WebWaka deployment encountered issues"
          echo "ğŸ¤ Ubuntu spirit calls for healing and community support"
          echo "ğŸ”§ Please check the deployment logs and resolve issues"
          echo "ğŸŒ Sawubona! We will overcome challenges together"

  # Cleanup on failure
  cleanup-on-failure:
    name: ğŸ§¹ Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [ubuntu-validation, deploy-infrastructure, deploy-application, post-deployment-tests]
    if: failure() && needs.ubuntu-validation.outputs.ubuntu-blessed == 'true'
    steps:
      - name: ğŸ§¹ Rollback deployment
        run: |
          echo "ğŸ§¹ Rolling back failed deployment"
          echo "ğŸ¤ Ubuntu philosophy: Learning from challenges to serve community better"
          # Add rollback logic here if needed
          echo "âœ… Rollback completed - system restored to previous stable state"

